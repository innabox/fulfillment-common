/*
Copyright (c) 2025 Red Hat Inc.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
License. You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
language governing permissions and limitations under the License.
*/

package oauth

import (
	"context"
	"fmt"
	"net/http"
	"time"

	. "github.com/onsi/ginkgo/v2/dsl/core"
	. "github.com/onsi/gomega"
	. "github.com/onsi/gomega/ghttp"
	"go.uber.org/mock/gomock"

	"github.com/innabox/fulfillment-common/auth"
)

var _ = Describe("Credentials flow", func() {
	var (
		ctx    context.Context
		ctrl   *gomock.Controller
		store  auth.TokenStore
		server *Server
	)

	BeforeEach(func() {
		var err error

		// Create the context:
		ctx = context.Background()

		// Create the mock controller:
		ctrl = gomock.NewController(GinkgoT())
		DeferCleanup(ctrl.Finish)

		// Create an empty token store:
		store, err = auth.NewMemoryTokenStore().
			SetLogger(logger).
			Build()
		Expect(err).ToNot(HaveOccurred())

		// Create the server that responds to the discovery requests any number of times. Other responses will
		// be added in specific tests.
		server = NewServer()
		DeferCleanup(server.Close)
		server.RouteToHandler(
			http.MethodGet,
			"/.well-known/oauth-authorization-server",
			RespondWithJSONEncoded(
				http.StatusOK,
				&ServerMetadata{
					Issuer:        server.URL(),
					TokenEndpoint: fmt.Sprintf("%s/token", server.URL()),
				},
				http.Header{
					"Content-Type": {
						"application/json",
					},
				},
			),
		)
	})

	respondWithToken := RespondWithJSONEncoded(
		http.StatusOK,
		map[string]any{
			"access_token":  "my_access_token",
			"refresh_token": "my_refresh_token",
			"token_type":    "Bearer",
			"expires_in":    3600,
		},
	)

	respondWithError := RespondWithJSONEncoded(
		http.StatusUnauthorized,
		map[string]any{
			"error": "invalid_client",
		},
	)

	It("Returns the token generated by the authorization server", func() {
		// Prepare the server to responde to the token request with a valid token.
		server.AppendHandlers(
			CombineHandlers(
				VerifyRequest(http.MethodPost, "/token"),
				respondWithToken,
			),
		)

		// Create the source and request the token:
		source, err := NewTokenSource().
			SetLogger(logger).
			SetIssuer(server.URL()).
			SetFlow(CredentialsFlow).
			SetClientId("my_client").
			SetClientSecret("my_secret").
			SetStore(store).
			Build()
		Expect(err).ToNot(HaveOccurred())
		token, err := source.Token(context.Background())
		Expect(err).ToNot(HaveOccurred())

		// Verify that the token is the one returned by the server:
		Expect(token).ToNot(BeNil())
		Expect(token.Access).To(Equal("my_access_token"))
		Expect(token.Refresh).To(Equal("my_refresh_token"))
		Expect(token.Expiry).To(BeTemporally("~", time.Now().Add(3600*time.Second), time.Second))
	})

	It("Uses an existing valid token from storage", func() {
		// Prepare the store with a valid token:
		err := store.Save(ctx, &auth.Token{
			Access: "my-stored-token",
		})
		Expect(err).ToNot(HaveOccurred())

		// Create the source:
		source, err := NewTokenSource().
			SetLogger(logger).
			SetIssuer(server.URL()).
			SetFlow(CredentialsFlow).
			SetClientId("my_client").
			SetClientSecret("my_secret").
			SetStore(store).
			Build()
		Expect(err).ToNot(HaveOccurred())

		// Verify that the token is the one returned from the store:
		token, err := source.Token(ctx)
		Expect(err).ToNot(HaveOccurred())
		Expect(token).ToNot(BeNil())
		Expect(token.Access).To(Equal("my-stored-token"))
	})

	It("Saves the token to storage after successful retrieval", func() {
		// Prepare the server to respond to the token request with a valid token.
		server.AppendHandlers(
			CombineHandlers(
				VerifyRequest(http.MethodPost, "/token"),
				respondWithToken,
			),
		)

		// Create the source:
		source, err := NewTokenSource().
			SetLogger(logger).
			SetIssuer(server.URL()).
			SetFlow(CredentialsFlow).
			SetClientId("my_client").
			SetClientSecret("my_secret").
			SetStore(store).
			Build()
		Expect(err).ToNot(HaveOccurred())
		_, err = source.Token(context.Background())
		Expect(err).ToNot(HaveOccurred())

		// Verify that the token was saved:
		saved, err := store.Load(ctx)
		Expect(err).ToNot(HaveOccurred())
		Expect(saved).ToNot(BeNil())
		Expect(saved.Access).To(Equal("my_access_token"))
	})

	It("Returns an error when the token save function fails", func() {
		// Prepare the server to responde to the token request with a valid token.
		server.AppendHandlers(
			CombineHandlers(
				VerifyRequest(http.MethodPost, "/token"),
				respondWithToken,
			),
		)

		// For this test we can't use the memory store, as that never fails, so we use a mock instead:
		store := auth.NewMockTokenStore(ctrl)
		store.EXPECT().Load(gomock.Any()).
			Return(nil, nil).
			AnyTimes()
		store.EXPECT().Save(gomock.Any(), gomock.Any()).
			Return(fmt.Errorf("my save error")).
			AnyTimes()

		// Create the source:
		source, err := NewTokenSource().
			SetLogger(logger).
			SetIssuer(server.URL()).
			SetFlow(CredentialsFlow).
			SetClientId("my_client").
			SetClientSecret("my_secret").
			SetStore(store).
			Build()
		Expect(err).ToNot(HaveOccurred())

		// Verify that the save error is returned.
		token, err := source.Token(context.Background())
		Expect(err).To(MatchError("failed to save token: my save error"))
		Expect(token).To(BeNil())
	})

	It("Returns an error when the token load function fails", func() {
		// For this test we can't use the memory store, as that never fails, so we use a mock instead:
		store := auth.NewMockTokenStore(ctrl)
		store.EXPECT().Load(gomock.Any()).
			Return(nil, fmt.Errorf("my load error")).
			AnyTimes()
		store.EXPECT().Save(gomock.Any(), gomock.Any()).
			Return(nil).
			AnyTimes()

		// Create the source:
		source, err := NewTokenSource().
			SetLogger(logger).
			SetIssuer(server.URL()).
			SetFlow(CredentialsFlow).
			SetClientId("my_client").
			SetClientSecret("my_secret").
			SetStore(store).
			Build()
		Expect(err).ToNot(HaveOccurred())

		// Verify that the load error is returned.
		token, err := source.Token(context.Background())
		Expect(err).To(MatchError("failed to load token: my load error"))
		Expect(token).To(BeNil())
	})

	It("Returns an error when the server returns an error", func() {
		// Prepare the server to responde to the token request with an error.
		server.RouteToHandler(
			http.MethodPost,
			"/token",
			CombineHandlers(
				VerifyRequest(http.MethodPost, "/token"),
				respondWithError,
			),
		)

		// Create the source and verify that it returns an error.
		source, err := NewTokenSource().
			SetLogger(logger).
			SetIssuer(server.URL()).
			SetFlow(CredentialsFlow).
			SetClientId("bad_client_id").
			SetClientSecret("bad_client_secret").
			SetStore(store).
			Build()
		Expect(err).ToNot(HaveOccurred())

		// Verify that the error is returned:
		token, err := source.Token(context.Background())
		Expect(err).To(MatchError(ContainSubstring("failed to obtain token:")))
		Expect(token).To(BeNil())
	})

	It("Sends the client credentials in the request", func() {
		// Prepare a server that verfies that the client credentials are sent using basic
		// authentication.
		server.AppendHandlers(
			CombineHandlers(
				VerifyFormKV("client_id", "my_client_id"),
				VerifyFormKV("client_secret", "my_client_secret"),
				respondWithToken,
			),
		)

		// Create the source:
		source, err := NewTokenSource().
			SetLogger(logger).
			SetIssuer(server.URL()).
			SetFlow(CredentialsFlow).
			SetClientId("my_client_id").
			SetClientSecret("my_client_secret").
			SetStore(store).
			Build()
		Expect(err).ToNot(HaveOccurred())

		// Request the token:
		_, err = source.Token(ctx)
		Expect(err).ToNot(HaveOccurred())
	})

	It("Sends one scope", func() {
		// Prepare a server that verfies that the one scope is sent in the request body:
		server.AppendHandlers(
			CombineHandlers(
				VerifyFormKV("scope", "read"),
				respondWithToken,
			),
		)

		// Create the source:
		source, err := NewTokenSource().
			SetLogger(logger).
			SetIssuer(server.URL()).
			SetFlow(CredentialsFlow).
			SetClientId("my_client").
			SetClientSecret("my_secret").
			SetScopes("read").
			SetStore(store).
			Build()
		Expect(err).ToNot(HaveOccurred())
		Expect(source).ToNot(BeNil())

		// Request the token:
		_, err = source.Token(ctx)
		Expect(err).ToNot(HaveOccurred())
	})

	It("Sends multiple scopes", func() {
		// Prepare a server that verfies that the multiple scopes are sent in the request body:
		server.AppendHandlers(
			CombineHandlers(
				VerifyFormKV("scope", "read", "write", "admin"),
				respondWithToken,
			),
		)

		// Create the source:
		source, err := NewTokenSource().
			SetLogger(logger).
			SetIssuer(server.URL()).
			SetFlow(CredentialsFlow).
			SetClientId("my_client").
			SetClientSecret("my_secret").
			SetScopes("read", "write", "admin").
			SetStore(store).
			Build()
		Expect(err).ToNot(HaveOccurred())
		Expect(source).ToNot(BeNil())
	})

	It("Doesn't send scopes when none are provided", func() {
		// Prepare a server that verfies that no scopes are sent in the request body:
		server.AppendHandlers(
			CombineHandlers(
				func(w http.ResponseWriter, r *http.Request) {
					Expect(r.Form).ToNot(HaveKey("scope"))
				},
				respondWithToken,
			),
		)

		// Create the source:
		source, err := NewTokenSource().
			SetLogger(logger).
			SetIssuer(server.URL()).
			SetFlow(CredentialsFlow).
			SetClientId("my_client").
			SetClientSecret("my_secret").
			SetStore(store).
			Build()
		Expect(err).ToNot(HaveOccurred())

		// Request the token:
		_, err = source.Token(ctx)
		Expect(err).ToNot(HaveOccurred())
	})
})

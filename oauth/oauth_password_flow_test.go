/*
Copyright (c) 2025 Red Hat Inc.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
License. You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
language governing permissions and limitations under the License.
*/

package oauth

import (
	"context"
	"fmt"
	"net/http"
	"time"

	. "github.com/onsi/ginkgo/v2/dsl/core"
	. "github.com/onsi/gomega"
	. "github.com/onsi/gomega/ghttp"
	"go.uber.org/mock/gomock"

	"github.com/innabox/fulfillment-common/auth"
)

var _ = Describe("Password flow", func() {
	var (
		ctx    context.Context
		ctrl   *gomock.Controller
		store  auth.TokenStore
		server *Server
	)

	BeforeEach(func() {
		var err error

		// Create the context:
		ctx = context.Background()

		// Create the mock controller:
		ctrl = gomock.NewController(GinkgoT())
		DeferCleanup(ctrl.Finish)

		// Create an empty token store:
		store, err = auth.NewMemoryTokenStore().
			SetLogger(logger).
			Build()
		Expect(err).ToNot(HaveOccurred())

		// Create the server that responds to the discovery requests any number of times. Other responses will
		// be added in specific tests.
		server = NewServer()
		DeferCleanup(server.Close)
		server.RouteToHandler(
			http.MethodGet,
			"/.well-known/oauth-authorization-server",
			RespondWithJSONEncoded(
				http.StatusOK,
				&ServerMetadata{
					Issuer:        server.URL(),
					TokenEndpoint: fmt.Sprintf("%s/token", server.URL()),
				},
				http.Header{
					"Content-Type": {
						"application/json",
					},
				},
			),
		)
	})

	respondWithToken := RespondWithJSONEncoded(
		http.StatusOK,
		map[string]any{
			"access_token":  "my_access_token",
			"refresh_token": "my_refresh_token",
			"token_type":    "Bearer",
			"expires_in":    3600,
		},
	)

	respondWithError := RespondWithJSONEncoded(
		http.StatusUnauthorized,
		map[string]any{
			"error": "invalid_grant",
		},
	)

	It("Returns the token generated by the authorization server", func() {
		// Prepare the server to respond to the token request with a valid token.
		server.AppendHandlers(
			CombineHandlers(
				VerifyRequest(http.MethodPost, "/token"),
				respondWithToken,
			),
		)

		// Create the source and request the token:
		source, err := NewTokenSource().
			SetLogger(logger).
			SetIssuer(server.URL()).
			SetFlow(PasswordFlow).
			SetClientId("my_client").
			SetUsername("my_user").
			SetPassword("my_password").
			SetStore(store).
			Build()
		Expect(err).ToNot(HaveOccurred())
		token, err := source.Token(context.Background())
		Expect(err).ToNot(HaveOccurred())

		// Verify that the token is the one returned by the server:
		Expect(token).ToNot(BeNil())
		Expect(token.Access).To(Equal("my_access_token"))
		Expect(token.Refresh).To(Equal("my_refresh_token"))
		Expect(token.Expiry).To(BeTemporally("~", time.Now().Add(3600*time.Second), time.Second))
	})

	It("Uses an existing valid token from storage", func() {
		// Prepare the store with a valid token:
		err := store.Save(ctx, &auth.Token{
			Access: "my-stored-token",
		})
		Expect(err).ToNot(HaveOccurred())

		// Create the source:
		source, err := NewTokenSource().
			SetLogger(logger).
			SetIssuer(server.URL()).
			SetFlow(PasswordFlow).
			SetClientId("my_client").
			SetUsername("my_user").
			SetPassword("my_password").
			SetStore(store).
			Build()
		Expect(err).ToNot(HaveOccurred())

		// Verify that the token is the one returned from the store:
		token, err := source.Token(ctx)
		Expect(err).ToNot(HaveOccurred())
		Expect(token).ToNot(BeNil())
		Expect(token.Access).To(Equal("my-stored-token"))
	})

	It("Saves the token to storage after successful retrieval", func() {
		// Prepare the server to respond to the token request with a valid token.
		server.AppendHandlers(
			CombineHandlers(
				VerifyRequest(http.MethodPost, "/token"),
				respondWithToken,
			),
		)

		// Create the source:
		source, err := NewTokenSource().
			SetLogger(logger).
			SetIssuer(server.URL()).
			SetFlow(PasswordFlow).
			SetClientId("my_client").
			SetUsername("my_user").
			SetPassword("my_password").
			SetStore(store).
			Build()
		Expect(err).ToNot(HaveOccurred())
		_, err = source.Token(context.Background())
		Expect(err).ToNot(HaveOccurred())

		// Verify that the token was saved:
		saved, err := store.Load(ctx)
		Expect(err).ToNot(HaveOccurred())
		Expect(saved).ToNot(BeNil())
		Expect(saved.Access).To(Equal("my_access_token"))
	})

	It("Returns an error when the token save function fails", func() {
		// Prepare the server to respond to the token request with a valid token.
		server.AppendHandlers(
			CombineHandlers(
				VerifyRequest(http.MethodPost, "/token"),
				respondWithToken,
			),
		)

		// For this test we can't use the memory store, as that never fails, so we use a mock instead:
		store := auth.NewMockTokenStore(ctrl)
		store.EXPECT().Load(gomock.Any()).
			Return(nil, nil).
			AnyTimes()
		store.EXPECT().Save(gomock.Any(), gomock.Any()).
			Return(fmt.Errorf("my save error")).
			AnyTimes()

		// Create the source:
		source, err := NewTokenSource().
			SetLogger(logger).
			SetIssuer(server.URL()).
			SetFlow(PasswordFlow).
			SetClientId("my_client").
			SetUsername("my_user").
			SetPassword("my_password").
			SetStore(store).
			Build()
		Expect(err).ToNot(HaveOccurred())

		// Verify that the save error is returned.
		token, err := source.Token(context.Background())
		Expect(err).To(MatchError("failed to save token: my save error"))
		Expect(token).To(BeNil())
	})

	It("Returns an error when the token load function fails", func() {
		// For this test we can't use the memory store, as that never fails, so we use a mock instead:
		store := auth.NewMockTokenStore(ctrl)
		store.EXPECT().Load(gomock.Any()).
			Return(nil, fmt.Errorf("my load error")).
			AnyTimes()
		store.EXPECT().Save(gomock.Any(), gomock.Any()).
			Return(nil).
			AnyTimes()

		// Create the source:
		source, err := NewTokenSource().
			SetLogger(logger).
			SetIssuer(server.URL()).
			SetFlow(PasswordFlow).
			SetClientId("my_client").
			SetUsername("my_user").
			SetPassword("my_password").
			SetStore(store).
			Build()
		Expect(err).ToNot(HaveOccurred())

		// Verify that the load error is returned.
		token, err := source.Token(context.Background())
		Expect(err).To(MatchError("failed to load token: my load error"))
		Expect(token).To(BeNil())
	})

	It("Returns an error when the server returns an error", func() {
		// Prepare the server to respond to the token request with an error.
		server.RouteToHandler(
			http.MethodPost,
			"/token",
			CombineHandlers(
				VerifyRequest(http.MethodPost, "/token"),
				respondWithError,
			),
		)

		// Create the source and verify that it returns an error.
		source, err := NewTokenSource().
			SetLogger(logger).
			SetIssuer(server.URL()).
			SetFlow(PasswordFlow).
			SetClientId("my_client").
			SetUsername("bad_user").
			SetPassword("bad_password").
			SetStore(store).
			Build()
		Expect(err).ToNot(HaveOccurred())

		// Verify that the error is returned:
		token, err := source.Token(context.Background())
		Expect(err).To(MatchError(ContainSubstring("failed to obtain token:")))
		Expect(token).To(BeNil())
	})

	It("Sends the username and password in the request", func() {
		// Prepare a server that verifies that the username and password are sent in the request.
		server.AppendHandlers(
			CombineHandlers(
				VerifyFormKV("username", "my_username"),
				VerifyFormKV("password", "my_password"),
				VerifyFormKV("grant_type", "password"),
				respondWithToken,
			),
		)

		// Create the source:
		source, err := NewTokenSource().
			SetLogger(logger).
			SetIssuer(server.URL()).
			SetFlow(PasswordFlow).
			SetClientId("my_client").
			SetUsername("my_username").
			SetPassword("my_password").
			SetStore(store).
			Build()
		Expect(err).ToNot(HaveOccurred())

		// Request the token:
		_, err = source.Token(ctx)
		Expect(err).ToNot(HaveOccurred())
	})

	It("Sends the client identifier in the request", func() {
		// Prepare a server that verifies that the client identifier is sent in the request.
		server.AppendHandlers(
			CombineHandlers(
				VerifyFormKV("client_id", "my_client_id"),
				respondWithToken,
			),
		)

		// Create the source:
		source, err := NewTokenSource().
			SetLogger(logger).
			SetIssuer(server.URL()).
			SetFlow(PasswordFlow).
			SetClientId("my_client_id").
			SetUsername("my_user").
			SetPassword("my_password").
			SetStore(store).
			Build()
		Expect(err).ToNot(HaveOccurred())

		// Request the token:
		_, err = source.Token(ctx)
		Expect(err).ToNot(HaveOccurred())
	})

	It("Sends the client secret in the request", func() {
		// Prepare a server that verifies that the client secret is sent in the request.
		server.AppendHandlers(
			CombineHandlers(
				VerifyFormKV("client_secret", "my_client_secret"),
				respondWithToken,
			),
		)

		// Create the source:
		source, err := NewTokenSource().
			SetLogger(logger).
			SetIssuer(server.URL()).
			SetFlow(PasswordFlow).
			SetClientId("my_client").
			SetClientSecret("my_client_secret").
			SetUsername("my_user").
			SetPassword("my_password").
			SetStore(store).
			Build()
		Expect(err).ToNot(HaveOccurred())

		// Request the token:
		_, err = source.Token(ctx)
		Expect(err).ToNot(HaveOccurred())
	})

	It("Sends one scope", func() {
		// Prepare a server that verifies that the one scope is sent in the request body:
		server.AppendHandlers(
			CombineHandlers(
				VerifyFormKV("scope", "read"),
				respondWithToken,
			),
		)

		// Create the source:
		source, err := NewTokenSource().
			SetLogger(logger).
			SetIssuer(server.URL()).
			SetFlow(PasswordFlow).
			SetClientId("my_client").
			SetUsername("my_user").
			SetPassword("my_password").
			SetScopes("read").
			SetStore(store).
			Build()
		Expect(err).ToNot(HaveOccurred())
		Expect(source).ToNot(BeNil())

		// Request the token:
		_, err = source.Token(ctx)
		Expect(err).ToNot(HaveOccurred())
	})

	It("Sends multiple scopes", func() {
		// Prepare a server that verifies that the multiple scopes are sent in the request body as a space-separated
		// string (the scopes are sorted, so "admin", "read", "write" becomes "admin read write"):
		server.AppendHandlers(
			CombineHandlers(
				VerifyFormKV("scope", "admin read write"),
				respondWithToken,
			),
		)

		// Create the source:
		source, err := NewTokenSource().
			SetLogger(logger).
			SetIssuer(server.URL()).
			SetFlow(PasswordFlow).
			SetClientId("my_client").
			SetUsername("my_user").
			SetPassword("my_password").
			SetScopes("read", "write", "admin").
			SetStore(store).
			Build()
		Expect(err).ToNot(HaveOccurred())
		Expect(source).ToNot(BeNil())

		// Request the token:
		_, err = source.Token(ctx)
		Expect(err).ToNot(HaveOccurred())
	})

	It("Doesn't send scopes when none are provided", func() {
		// Prepare a server that verifies that no scopes are sent in the request body:
		server.AppendHandlers(
			CombineHandlers(
				func(w http.ResponseWriter, r *http.Request) {
					Expect(r.Form).ToNot(HaveKey("scope"))
				},
				respondWithToken,
			),
		)

		// Create the source:
		source, err := NewTokenSource().
			SetLogger(logger).
			SetIssuer(server.URL()).
			SetFlow(PasswordFlow).
			SetClientId("my_client").
			SetUsername("my_user").
			SetPassword("my_password").
			SetStore(store).
			Build()
		Expect(err).ToNot(HaveOccurred())

		// Request the token:
		_, err = source.Token(ctx)
		Expect(err).ToNot(HaveOccurred())
	})

	It("Returns an error when username is not provided", func() {
		// Create the source without username:
		_, err := NewTokenSource().
			SetLogger(logger).
			SetIssuer(server.URL()).
			SetFlow(PasswordFlow).
			SetClientId("my_client").
			SetPassword("my_password").
			SetStore(store).
			Build()
		Expect(err).To(MatchError("username is mandatory for the resource owner password credentials flow"))
	})

	It("Returns an error when password is not provided", func() {
		// Create the source without password:
		_, err := NewTokenSource().
			SetLogger(logger).
			SetIssuer(server.URL()).
			SetFlow(PasswordFlow).
			SetClientId("my_client").
			SetUsername("my_user").
			SetStore(store).
			Build()
		Expect(err).To(MatchError("password is mandatory for the resource owner password credentials flow"))
	})
})

/*
Copyright (c) 2025 Red Hat Inc.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
License. You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
language governing permissions and limitations under the License.
*/

package auth

import (
	"context"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"time"

	. "github.com/innabox/fulfillment-common/testing"
	. "github.com/onsi/ginkgo/v2/dsl/core"
	. "github.com/onsi/gomega"
	"go.uber.org/mock/gomock"
)

var _ = Describe("Script token source", func() {
	var (
		ctx  context.Context
		ctrl *gomock.Controller
	)

	BeforeEach(func() {
		ctx = context.Background()
		ctrl = gomock.NewController(GinkgoT())
		DeferCleanup(ctrl.Finish)
	})

	Describe("Creation", func() {
		It("Can be created with all the mandatory parameters", func() {
			source, err := NewScriptTokenSource().
				SetLogger(logger).
				SetScript("echo mytoken").
				SetStore(NewMockTokenStore(ctrl)).
				Build()
			Expect(err).ToNot(HaveOccurred())
			Expect(source).ToNot(BeNil())
		})

		It("Can't be created without a logger", func() {
			source, err := NewScriptTokenSource().
				SetScript("echo mytoken").
				SetStore(NewMockTokenStore(ctrl)).
				Build()
			Expect(err).To(MatchError("logger is mandatory"))
			Expect(source).To(BeNil())
		})

		It("Can't be created without a script", func() {
			source, err := NewScriptTokenSource().
				SetLogger(logger).
				SetStore(NewMockTokenStore(ctrl)).
				Build()
			Expect(err).To(MatchError("token generation script is mandatory"))
			Expect(source).To(BeNil())
		})

		It("Can't be created without a token store", func() {
			source, err := NewScriptTokenSource().
				SetLogger(logger).
				SetScript("echo mytoken").
				Build()
			Expect(err).To(MatchError("token store is mandatory"))
			Expect(source).To(BeNil())
		})
	})

	Describe("Behaviour", func() {
		It("Returns the token generated by the script", func() {
			// Prepare a store that doesn't have any token:
			store, err := NewMemoryTokenStore().
				SetLogger(logger).
				Build()
			Expect(err).ToNot(HaveOccurred())

			// Create the source:
			source, err := NewScriptTokenSource().
				SetLogger(logger).
				SetScript("echo my-token").
				SetStore(store).
				Build()
			Expect(err).ToNot(HaveOccurred())

			// Verify that the token is generated by the script:
			token, err := source.Token(ctx)
			Expect(err).ToNot(HaveOccurred())
			Expect(token).ToNot(BeNil())
			Expect(token.Access).To(Equal("my-token"))
		})

		It("Generates a new token for each call if the token isn't a JWT", func() {
			// Prepare a store that doesn't have any token:
			store, err := NewMemoryTokenStore().
				SetLogger(logger).
				Build()
			Expect(err).ToNot(HaveOccurred())

			// For this test we will use a script that reads a token from a file, so that we can change the
			// token between calls, so we need to create that file.
			tmpDir, err := os.MkdirTemp("", "*.test")
			Expect(err).ToNot(HaveOccurred())
			defer func() {
				err := os.RemoveAll(tmpDir)
				Expect(err).ToNot(HaveOccurred())
			}()
			tmpFile := filepath.Join(tmpDir, "token.txt")

			// Create the source with the script that reads from a file in the temporary directory:
			script := fmt.Sprintf("cat %s", tmpFile)
			source, err := NewScriptTokenSource().
				SetLogger(logger).
				SetScript(script).
				SetStore(store).
				Build()
			Expect(err).ToNot(HaveOccurred())

			// Write the first token and verify that it is returned:
			err = os.WriteFile(tmpFile, []byte("first"), 0600)
			Expect(err).ToNot(HaveOccurred())
			token, err := source.Token(ctx)
			Expect(err).ToNot(HaveOccurred())
			Expect(token).ToNot(BeNil())
			Expect(token.Access).To(Equal("first"))

			// Write the second token and verify that it is returned:
			err = os.WriteFile(tmpFile, []byte("second"), 0600)
			Expect(err).ToNot(HaveOccurred())
			token, err = source.Token(ctx)
			Expect(err).ToNot(HaveOccurred())
			Expect(token).ToNot(BeNil())
			Expect(token.Access).To(Equal("second"))
		})

		It("Doesn't use the loaded token if it isn't a JWT", func() {
			// Prepare a store that returns a token that isn't a JWT:
			store, err := NewMemoryTokenStore().
				SetLogger(logger).
				Build()
			Expect(err).ToNot(HaveOccurred())
			err = store.Save(ctx, &Token{
				Access: "my-stored-token",
			})
			Expect(err).ToNot(HaveOccurred())

			// Create the source:
			source, err := NewScriptTokenSource().
				SetLogger(logger).
				SetScript("echo my-generated-token").
				SetStore(store).
				Build()
			Expect(err).ToNot(HaveOccurred())
			token, err := source.Token(ctx)

			// Verify that the token is the one generated by the script:
			Expect(err).ToNot(HaveOccurred())
			Expect(token).ToNot(BeNil())
			Expect(token.Access).To(Equal("my-generated-token"))
		})

		It("Doesn't save the token if it isn't a JWT", func() {
			// Prepare an empty store:
			store, err := NewMemoryTokenStore().
				SetLogger(logger).
				Build()
			Expect(err).ToNot(HaveOccurred())

			// Create the source:
			source, err := NewScriptTokenSource().
				SetLogger(logger).
				SetScript("echo my-generated-token").
				SetStore(store).
				Build()
			Expect(err).ToNot(HaveOccurred())

			// Verify that the token isn't saved:
			_, err = source.Token(ctx)
			Expect(err).ToNot(HaveOccurred())
			token, err := store.Load(ctx)
			Expect(err).ToNot(HaveOccurred())
			Expect(token).To(BeNil())
		})

		It("Returns the loaded token if it is a JWT that hasn't expired", func() {
			// Prepare a store that returns a token that is a JWT and hasn't expired:
			loaded := &Token{
				Access: MakeTokenString("Bearer", 5*time.Minute),
			}
			store, err := NewMemoryTokenStore().
				SetLogger(logger).
				Build()
			Expect(err).ToNot(HaveOccurred())
			err = store.Save(ctx, &Token{
				Access: MakeTokenString("Bearer", 5*time.Minute),
			})
			Expect(err).ToNot(HaveOccurred())

			// Create the source:
			source, err := NewScriptTokenSource().
				SetLogger(logger).
				SetScript("echo my-generated-token").
				SetStore(store).
				Build()
			Expect(err).ToNot(HaveOccurred())
			token, err := source.Token(ctx)

			// Verify that the returned token is the one from the store:
			Expect(err).ToNot(HaveOccurred())
			Expect(token).ToNot(BeNil())
			Expect(token.Access).To(Equal(loaded.Access))
		})

		It("Saves the generated token if it is a JWT that hasn't expired", func() {
			// Prepare an empty store:
			store, err := NewMemoryTokenStore().
				SetLogger(logger).
				Build()
			Expect(err).ToNot(HaveOccurred())

			// Create the source:
			generated := &Token{
				Access: MakeTokenString("Bearer", 5*time.Minute),
			}
			script := fmt.Sprintf("echo '%s'", generated.Access)
			source, err := NewScriptTokenSource().
				SetLogger(logger).
				SetScript(script).
				SetStore(store).
				Build()
			Expect(err).ToNot(HaveOccurred())

			// Verify that the returned token is the one generated by the script:
			token, err := source.Token(ctx)
			Expect(err).ToNot(HaveOccurred())
			Expect(token).ToNot(BeNil())
			Expect(token.Access).To(Equal(generated.Access))
		})

		It("Generates a new token if the current one is a JWT that has expired", func() {
			// Prepare an empty store:
			store, err := NewMemoryTokenStore().
				SetLogger(logger).
				Build()
			Expect(err).ToNot(HaveOccurred())
			err = store.Save(ctx, &Token{
				Access: MakeTokenString("Bearer", -5*time.Minute),
			})
			Expect(err).ToNot(HaveOccurred())

			// Create the source:
			generated := &Token{
				Access: MakeTokenString("Bearer", 5*time.Minute),
			}
			script := fmt.Sprintf("echo '%s'", generated.Access)
			source, err := NewScriptTokenSource().
				SetLogger(logger).
				SetScript(script).
				SetStore(store).
				Build()
			Expect(err).ToNot(HaveOccurred())

			// Verify that the returned token is the one generated by the script:
			token, err := source.Token(ctx)
			Expect(err).ToNot(HaveOccurred())
			Expect(token).ToNot(BeNil())
			Expect(token.Access).To(Equal(generated.Access))
		})

		It("Returns an error if the token load operation fails", func() {
			// Set up mock expectations - load returns an error
			store := NewMockTokenStore(ctrl)
			store.EXPECT().Load(gomock.Any()).Return(nil, errors.New("my load error")).Times(1)

			// Create the source:
			source, err := NewScriptTokenSource().
				SetLogger(logger).
				SetScript("echo mytoken").
				SetStore(store).
				Build()
			Expect(err).ToNot(HaveOccurred())

			// Verify that the error is returned:
			token, err := source.Token(ctx)
			Expect(err).To(MatchError("my load error"))
			Expect(token).To(BeNil())
		})

		It("Returns an error if the token save operation fails", func() {
			// Prepare a store that fails to save:
			store := NewMockTokenStore(ctrl)
			store.EXPECT().Load(gomock.Any()).
				Return(nil, nil).
				AnyTimes()
			store.EXPECT().Save(gomock.Any(), gomock.Any()).
				Return(errors.New("my save error")).
				AnyTimes()

			// Create the source:
			generated := &Token{
				Access: MakeTokenString("Bearer", 5*time.Minute),
			}
			script := fmt.Sprintf("echo '%s'", generated.Access)
			source, err := NewScriptTokenSource().
				SetLogger(logger).
				SetScript(script).
				SetStore(store).
				Build()
			Expect(err).ToNot(HaveOccurred())

			// Verify that the error is returned:
			token, err := source.Token(ctx)
			Expect(err).To(MatchError("my save error"))
			Expect(token).To(BeNil())
		})

		It("Returns an error if the script exists with non zero code", func() {
			// Prepare an empty store:
			store, err := NewMemoryTokenStore().
				SetLogger(logger).
				Build()
			Expect(err).ToNot(HaveOccurred())

			// Create the source:
			source, err := NewScriptTokenSource().
				SetLogger(logger).
				SetScript("exit 1").
				SetStore(store).
				Build()
			Expect(err).ToNot(HaveOccurred())

			// Verify that the error is returned:
			token, err := source.Token(ctx)
			Expect(err).To(MatchError("failed to execute token generation script 'exit 1': exit status 1"))
			Expect(token).To(BeNil())
		})
	})
})
